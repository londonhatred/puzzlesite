<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Kay's Puzzle Site</title>
  <style>
    :root{
  font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;

  --bg0: #07060b;
  --bg1: #0b0f14;

  --text: #e7eef7;
  --muted: rgba(231,238,247,0.72);

  --stroke: rgba(231,238,247,0.14);
  --stroke2: rgba(231,238,247,0.18);

  --accent: #FF00FF;
  --accentSoft: rgba(255,0,255,0.18);
  --accentStroke: rgba(255,0,255,0.65);
}
    html, body { height: 100%; }
    body{
  margin:0;
  color: var(--text);
  background:
    radial-gradient(1200px 700px at 20% -10%, rgba(255,0,255,0.12), transparent 60%),
    radial-gradient(900px 600px at 90% 10%, rgba(140,198,255,0.08), transparent 55%),
    radial-gradient(1000px 700px at 50% 120%, rgba(98,255,184,0.06), transparent 60%),
    linear-gradient(180deg, var(--bg0), var(--bg1));
  overflow:auto;
}

/* ====== ARCADE / CRT OVERLAY ====== */
body::before{
  content:"";
  position: fixed;
  inset: 0;
  pointer-events: none;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(255,255,255,0.06) 0px,
      rgba(255,255,255,0.06) 1px,
      rgba(0,0,0,0) 2px,
      rgba(0,0,0,0) 4px
    );
  opacity: 0.07;
  mix-blend-mode: overlay;
  animation: crtFlicker 6.5s infinite;
}

body::after{
  content:"";
  position: fixed;
  inset: -20%;
  pointer-events: none;
  background:
    radial-gradient(60% 45% at 50% 35%, rgba(255,0,255,0.10), transparent 60%),
    radial-gradient(70% 55% at 50% 120%, rgba(0,0,0,0.45), transparent 65%),
    radial-gradient(90% 80% at 50% 50%, transparent 45%, rgba(0,0,0,0.55) 100%);
  opacity: 0.28;
}

@keyframes crtFlicker{
  0%, 100%{ opacity: 0.07; }
  8%{ opacity: 0.06; }
  12%{ opacity: 0.08; }
  27%{ opacity: 0.065; }
  31%{ opacity: 0.09; }
  55%{ opacity: 0.062; }
  58%{ opacity: 0.085; }
}
    header{
      position: sticky; top: 0; z-index: 10;
      background: rgba(11,15,20,0.9); backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(231,238,247,0.12);
      padding: 14px 16px;
      display:flex; gap:16px; align-items:center; justify-content:space-between;
    }
    .headerRight{ display:flex; flex-direction:column; align-items:flex-end; gap:8px; min-width: 260px; }
    .searchWrap{ display:flex; align-items:center; gap:8px; }
    #searchInput{
      width: 260px;
      max-width: 52vw;
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(231,238,247,0.18);
      background: rgba(231,238,247,0.08);
      color: #e7eef7;
      outline: none;
    }
    #searchInput::placeholder{ color: rgba(231,238,247,0.55); }
    #searchInput:focus{
  border-color: var(--accentStroke);
  box-shadow: 0 0 0 2px var(--accentSoft);
}

.textInput:focus{
  border-color: var(--accentStroke);
  box-shadow: 0 0 0 2px var(--accentSoft);
}
    .stats{ display:flex; gap:10px; flex-wrap:wrap; }
    .pill{
      padding: 6px 10px; border-radius: 999px;
      background: rgba(231,238,247,0.08);
      border: 1px solid rgba(231,238,247,0.12);
      font-size: 14px;
    }
    .pill.flash-green{ animation: pillGreen 380ms ease; }
    .pill.flash-red{ animation: pillRed 380ms ease; }

    @keyframes pillGreen{
      0%{ background: rgba(231,238,247,0.08); border-color: rgba(231,238,247,0.12); }
      30%{ background: rgba(98,255,184,0.18); border-color: rgba(98,255,184,0.55); }
      100%{ background: rgba(231,238,247,0.08); border-color: rgba(231,238,247,0.12); }
    }

    @keyframes pillRed{
      0%{ background: rgba(231,238,247,0.08); border-color: rgba(231,238,247,0.12); }
      30%{ background: rgba(255,98,98,0.18); border-color: rgba(255,98,98,0.55); }
      100%{ background: rgba(231,238,247,0.08); border-color: rgba(231,238,247,0.12); }
    }

    .pill strong{ font-variant-numeric: tabular-nums; }
    main{ padding: 14px 12px 28px; max-width: none; margin: 0; }
    .row{ display:flex; justify-content:space-between; gap:12px; align-items:baseline; margin-bottom:14px; }
    .hint{ opacity: 0.8; font-size: 13px; }
    button{
  background: linear-gradient(180deg, rgba(231,238,247,0.10), rgba(231,238,247,0.06));
  color: var(--text);
  border: 1px solid rgba(231,238,247,0.18);
  border-radius: 12px;
  padding: 8px 10px;
  cursor: pointer;
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.05);
  transition: transform 0.06s ease, background 0.12s ease, border-color 0.12s ease, box-shadow 0.12s ease;
}
button:hover{
  background: linear-gradient(180deg, rgba(231,238,247,0.14), rgba(231,238,247,0.08));
  transform: translateY(-1px);
}
button:active{ transform: translateY(0px) scale(0.99); }

button:disabled{
  opacity: 0.45;
  cursor: not-allowed;
  background: rgba(231,238,247,0.06);
  border-color: rgba(231,238,247,0.10);
  filter: grayscale(1);
  box-shadow: none;
}
button:disabled:hover{ transform:none; background: rgba(231,238,247,0.06); }

.btnPrimary{
  background: linear-gradient(180deg, rgba(255,0,255,0.30), rgba(255,0,255,0.16));
  border-color: rgba(255,0,255,0.55);
  box-shadow: 0 0 0 0 rgba(255,0,255,0), inset 0 1px 0 rgba(255,255,255,0.10);
}
.btnPrimary:hover{
  background: linear-gradient(180deg, rgba(255,0,255,0.36), rgba(255,0,255,0.18));
  box-shadow: 0 0 0 2px rgba(255,0,255,0.14), 0 0 18px rgba(255,0,255,0.12);
}

.btnGhost{
  background: rgba(231,238,247,0.04);
  border-color: rgba(231,238,247,0.14);
}

.btnDanger{
  background: linear-gradient(180deg, rgba(255,98,98,0.20), rgba(255,98,98,0.10));
  border-color: rgba(255,98,98,0.40);
}
.btnDanger:hover{
  background: linear-gradient(180deg, rgba(255,98,98,0.26), rgba(255,98,98,0.12));
}

    /* ====== VIEWS / ROUTING ====== */
    .view{ display:none; }
    .view.active{ display:block; }

    /* Home / Leaderboard basic layout */
    .shellHeader{
      position: sticky; top: 0; z-index: 10;
      background: rgba(11,15,20,0.9); backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(231,238,247,0.12);
      padding: 14px 16px;
      display:flex; gap:16px; align-items:center; justify-content:space-between;
    }
    .brand{
      font-weight: 900;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      text-shadow:
        0 0 18px rgba(255,0,255,0.20),
        0 0 2px rgba(255,0,255,0.25);
    }
    .homeMain{ padding: 18px 16px; max-width: 900px; margin: 0 auto; }
    .homeGrid{ display:grid; gap:12px; }
    .miniHint{ opacity:0.75; font-size:13px; margin-top:14px; }
    .nameRow{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end; }
    .nameRow label{ font-size:13px; opacity:0.85; }
    .textInput{
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(231,238,247,0.18);
      background: rgba(231,238,247,0.08);
      color: #e7eef7;
      outline:none;
    }
    .textInput:focus{ border-color: var(--accentStroke); box-shadow: 0 0 0 2px var(--accentSoft); }
    .btnRow{ display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; }
    .grid{
      display:grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 10px;
      align-items: stretch;
      padding: 0 4px;
    }
    .tile{
      user-select:none;
      border-radius:14px;
      border: 1px solid rgba(231,238,247,0.14);
      background: linear-gradient(180deg, rgba(231,238,247,0.07), rgba(231,238,247,0.04));
box-shadow: inset 0 1px 0 rgba(255,255,255,0.06), 0 10px 30px rgba(0,0,0,0.18);
      padding: 12px 12px 10px;
      cursor:pointer;
      transition: transform 0.06s ease, background 0.12s ease, border-color 0.12s ease;
      min-height:64px;
      display:flex; flex-direction:column; justify-content:center; gap:6px;
      height: 150px;
      overflow: hidden;
    }

    /* ====== MOBILE / SMALL SCREENS ====== */
    /* Use responsive layout instead of UA sniffing. This is the "detect mobile" approach. */
    @media (max-width: 640px) {
      header{ padding: 10px 10px; gap: 10px; }
      .headerRight{ min-width: 0; align-items: stretch; }
      .searchWrap{ width: 100%; }
      #searchInput{ width: 100%; max-width: 100%; }
      .stats{ gap: 8px; }
      .pill{ font-size: 12px; padding: 5px 8px; }
      .hint{ font-size: 12px; }

      /* Denser grid: smaller minimum tile width */
      .grid{ grid-template-columns: repeat(auto-fill, minmax(112px, 1fr)); gap: 8px; }

      /* Smaller fixed tile height and tighter padding */
      .tile{ height: 120px; min-height: 56px; padding: 10px 10px 8px; border-radius: 12px; }
      .title{ font-size: 14px; }
      .meta{ font-size: 11px; }

      /* Stack list preview area slightly smaller */
      .stackList{ max-height: 62px; margin-top: 6px; padding-top: 6px; }
      .chip{ font-size: 11px; padding: 3px 7px; }
    }

    /* Extra small phones */
    @media (max-width: 420px) {
      .grid{ grid-template-columns: repeat(auto-fill, minmax(104px, 1fr)); gap: 7px; }
      .tile{ height: 112px; }
      .title{ font-size: 13px; }
    }

    /* Touch devices: remove the tiny hover lift which can feel odd on tap */
    @media (pointer: coarse) {
      .tile:hover{ transform: none; }
    }
    .tile:hover{ transform: translateY(-1px); background: rgba(231,238,247,0.08); }
    .tile.selected{
  border-color: var(--accentStroke);
  box-shadow: 0 0 0 2px var(--accentSoft), 0 0 22px rgba(255,0,255,0.10), inset 0 1px 0 rgba(255,255,255,0.06);
  background: linear-gradient(180deg, rgba(255,0,255,0.12), rgba(231,238,247,0.05));
}
    .flash-green{ animation: flashGreen 380ms ease; }
    .flash-red{ animation: flashRed 380ms ease; }

    @keyframes flashGreen{
      0%{ box-shadow: 0 0 0 0 rgba(98,255,184,0); border-color: rgba(231,238,247,0.14); background: rgba(231,238,247,0.06); }
      30%{ box-shadow: 0 0 0 3px rgba(98,255,184,0.35); border-color: rgba(98,255,184,0.75); background: rgba(98,255,184,0.14); }
      100%{ box-shadow: 0 0 0 0 rgba(98,255,184,0); border-color: rgba(231,238,247,0.14); background: rgba(231,238,247,0.06); }
    }

    @keyframes flashRed{
      0%{ box-shadow: 0 0 0 0 rgba(255,98,98,0); border-color: rgba(231,238,247,0.14); background: rgba(231,238,247,0.06); }
      30%{ box-shadow: 0 0 0 3px rgba(255,98,98,0.30); border-color: rgba(255,98,98,0.8); background: rgba(255,98,98,0.12); }
      100%{ box-shadow: 0 0 0 0 rgba(255,98,98,0); border-color: rgba(231,238,247,0.14); background: rgba(231,238,247,0.06); }
    }

/* ====== FEEDBACK SHAKE (Step 1F) ====== */
.shake{ animation: shake 160ms ease-in-out; }
@keyframes shake{
  0%{ transform: translate3d(0,0,0); }
  20%{ transform: translate3d(-1px, 0, 0); }
  40%{ transform: translate3d(1px, 0, 0); }
  60%{ transform: translate3d(-1px, 0, 0); }
  80%{ transform: translate3d(1px, 0, 0); }
  100%{ transform: translate3d(0,0,0); }
}

    .title{ font-weight:600; line-height:1.1; }
    .meta{ font-size:12px; opacity:0.75; }

    /* Stack details (optional): shows the contents of merged stacks */
    .stackList{
      margin-top: 8px;
      display:none;
      padding-top:8px;
      border-top: 1px dashed rgba(231,238,247,0.18);
      gap:6px;
      flex-direction:column;
      max-height: 86px;
      overflow: hidden;
    }
    .tile.stack .stackList{ display:flex; }
    .chip{
      font-size:12px;
      background: rgba(231,238,247,0.08);
      border: 1px solid rgba(231,238,247,0.12);
      padding: 4px 8px;
      border-radius: 999px;
      width: fit-content;
    }
    .chip-ellipsis{ opacity: 0.75; }

    .locked{
      cursor: default;
      background: rgba(98, 255, 184, 0.10);
      border-color: rgba(98,255,184,0.35);
    }

    /* ====== Leaderboard ====== */
table{ width:100%; border-collapse: collapse; font-size:14px; }
th, td{ padding: 10px 10px; border-bottom: 1px solid rgba(231,238,247,0.12); text-align:left; }
th{ font-size:12px; text-transform: uppercase; letter-spacing: 0.08em; opacity:0.8; }
.muted{ opacity:0.75; }
    .mono{ font-variant-numeric: tabular-nums; }

    /* ====== How To Play Modal ====== */
    .modalOverlay{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.78);
      backdrop-filter: blur(14px);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 18px;
      z-index: 999;
    }
    .modalOverlay.active{ display: flex; }
    body.modal-open .view{
  filter: blur(10px);
  pointer-events: none;
  user-select: none;
}
body.modal-open #howToOverlay,
body.modal-open #finishOverlay,
body.modal-open #newsOverlay{ pointer-events: auto; }
    .modal{
      width: min(640px, 100%);
      background: rgba(11,15,20,0.96);
      border: 1px solid rgba(231,238,247,0.18);
      border-radius: 16px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.55);
      padding: 16px 16px 14px;
    }
    .modal h2{ margin: 0 0 8px; font-size: 18px; }
    .modal p{ margin: 0 0 10px; line-height: 1.35; opacity: 0.9; }
    .modal ul{ margin: 8px 0 14px 18px; padding: 0; opacity: 0.9; }
    .modal li{ margin: 6px 0; }
    .modalActions{ display:flex; gap:10px; justify-content:flex-end; margin-top: 12px; }
    /* ====== Finish Modal (Stacks) + Confetti ====== */
#finishOverlay{ background: rgba(0,0,0,0.78); backdrop-filter: blur(14px); }

.confettiLayer{
  position: fixed;
  inset: 0;
  pointer-events: none;
  overflow: hidden;
  z-index: 1000;
  display:none;
}
.confettiLayer.active{ display:block; }

.confetto{
  position:absolute;
  width: 8px;
  height: 14px;
  border-radius: 3px;
  opacity: 0.95;
  transform: translateY(-20px) rotate(0deg);
  animation: confettiFall 1200ms ease-in forwards;
}
@keyframes confettiFall{
  0%{ transform: translateY(-20px) rotate(0deg); opacity: 0.95; }
  90%{ opacity: 0.95; }
  100%{ transform: translateY(calc(100vh + 40px)) rotate(540deg); opacity: 0; }
}

    /* ====== Numerate layout ====== */
    .numerateWrap{ max-width: 860px; margin: 0 auto; }
    #numQuestion{ font-size: 20px; opacity: 0.92; }
    #numQuestionMeta{ font-size: 14px; }
    #numGuess{
      font-size: 18px;
      padding: 12px 14px;
      min-width: 340px !important;
    }
    #numLockBtn{ font-size: 16px; padding: 12px 14px; }
    #numReveal{ font-size: 16px; opacity: 0.9; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
  <!-- ====== HOME VIEW ====== -->
  <section id="view-home" class="view active">
    <div class="shellHeader">
      <div style="display:flex; align-items:baseline; gap:10px;">
        <div class="brand">Kay's Puzzle Stuff</div>
        <div class="pill" id="versionBadgeHome"></div>
      </div>
      <div class="nameRow">
        <label for="playerName">Name</label>
        <input id="playerName" class="textInput" type="text" placeholder="Kay" autocomplete="nickname" />
      </div>
    </div>

    <div class="homeMain">
      <div class="homeGrid">
        <button id="goStacks">Play Stacks</button>
        <button id="goNumerate" disabled>Numerate — Coming Soon</button>
        <button id="goTimeline" disabled>Timeline — Coming Soon</button>
        <button id="goLeaderboard">Leaderboard</button>
      </div>
      <div class="miniHint">This is a Kay Jupe doing. Stacks inspired by 2025 on thomaswc.com</div>
    </div>
  </section>

  <!-- ====== STACKS VIEW ====== -->
  <section id="view-stacks" class="view">
    <header>
      <div class="stats">
        <div class="pill">Time: <strong id="timer">00:00</strong></div>
        <div class="pill" id="correctPill">Correct links: <strong id="correctLinks">0</strong></div>
        <div class="pill" id="mistakesPill">Mistakes: <strong id="mistakes">0</strong></div>
        <div class="pill">Completed sets: <strong id="completedSets">0</strong></div>
        <div class="pill">Board: <strong id="boardSource">…</strong></div>
        <div class="pill" id="versionBadgeStacks"></div>
      </div>

      <div class="headerRight">
        <div class="searchWrap">
          <input id="searchInput" type="search" placeholder="Search tiles…" autocomplete="off" />
          <button id="clearSearchBtn" type="button" aria-label="Clear search">×</button>
        </div>
        <div class="hint">Timer starts on first click. Refresh-safe.</div>
      </div>
    </header>

    <main>
      <div class="row">
        <div class="hint">Demo uses 4 sets × 5 items. Full version will be 10 categories of 10 items.</div>
        <div class="btnRow">
          <button id="homeBtn">Home</button>
          <button id="leaderboardBtn">Leaderboard</button>
          <button id="resetBtn">Reset</button>
        </div>
      </div>
      <div class="grid" id="grid"></div>
    </main>
  </section>

  <!-- ====== NUMERATE VIEW ====== -->
  <section id="view-numerate" class="view">
    <header>
      <div class="stats">
        <div class="pill">Q: <strong id="numQ">0/5</strong></div>
        <div class="pill">Time: <strong id="numTime">10.0s</strong></div>
        <div class="pill">Total error: <strong id="numErr">0.00</strong></div>
      </div>

      <div class="headerRight">
        <div class="btnRow">
          <button id="numerateHomeBtn">Home</button>
          <button id="numerateLeaderboardBtn">Leaderboard</button>
          <button id="numerateResetBtn">Reset</button>
        </div>
        <div class="hint">10 seconds per question. Auto-lock at 0.</div>
      </div>
    </header>

    <div class="homeMain">
      <div class="numerateWrap">
        <div class="hint" id="numQuestion" style="margin: 8px 0 10px;"></div>
        <div class="hint" id="numQuestionMeta" style="margin: 0 0 10px; opacity:0.78;"></div>

        <div class="row" style="align-items:center; margin-bottom: 8px;">
          <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
            <input id="numGuess" class="textInput" type="text" inputmode="decimal" placeholder="Type a number…" />
            <button id="numLockBtn">Lock</button>
          </div>
        </div>

        <div id="numReveal" class="hint" style="margin-top:10px;"></div>
      </div>
    </div>
  </section>

  <!-- ====== TIMELINE VIEW ====== -->
  <section id="view-timeline" class="view">
    <header>
      <div class="stats">
        <div class="pill">Placed: <strong id="tlPlaced">0/10</strong></div>
        <div class="pill">Time: <strong id="tlTime">00:00</strong></div>
        <div class="pill">Score: <strong id="tlScore">0/10</strong></div>
      </div>

      <div class="headerRight">
        <div class="btnRow">
          <button id="timelineHomeBtn">Home</button>
          <button id="timelineLeaderboardBtn">Leaderboard</button>
          <button id="timelineResetBtn" disabled title="Coming next">Reset</button>
        </div>
        <div class="hint">Timeline is coming next. This is scaffolding.</div>
      </div>
    </header>

    <div class="homeMain">
      <div class="numerateWrap" style="text-align:center; padding-top: 18px;">
        <h2 style="margin: 0 0 10px;">Timeline</h2>
        <p class="muted" style="max-width: 620px; margin: 0 auto;">
          You’ll place historical events into a timeline (10 events), then get one final chance to reorder before locking in.
          Score is out of 10 and time is used for the leaderboard.
        </p>
        <div class="miniHint" style="margin-top: 12px;">(Gameplay wiring comes next — button and routing are live now.)</div>
      </div>
    </div>
  </section>

  <!-- ====== LEADERBOARD VIEW ====== -->
  <section id="view-leaderboard" class="view">
    <div class="shellHeader">
      <div>
        <div style="display:flex; align-items:baseline; gap:10px; flex-wrap:wrap;">
          <div class="brand">Leaderboard</div>
          <div class="pill" id="versionBadgeLB"></div>
        </div>
        <div class="miniHint">New board in: <span id="nextBoardIn" class="mono">--:--:--</span></div>
      </div>
      <div class="btnRow">
        <button id="backHomeFromLB">Home</button>
        <button id="goStacksFromLB">Stacks</button>
        <button id="goNumerateFromLB" disabled>Numerate — Coming Soon</button>
      </div>
    </div>

    <div class="homeMain">
      <div class="row" style="margin-bottom:12px; align-items:center;">
        <div class="hint">Shared leaderboard (live across devices). If Supabase is unavailable, it falls back to local.</div>
        <div class="btnRow">
          <button id="lbGameStacks">Stacks</button>
          <button id="lbGameNumerate" disabled>Numerate — Coming Soon</button>
          <button id="lbShowToday">Today</button>
          <button id="lbShowAllTime">All-time</button>
          <button id="lbClear" title="Deletes local leaderboard only">Clear</button>
        </div>
      </div>
      
      <div id="leaderboardContent" style="margin-top:12px;"></div>
    </div>
  </section>

  <!-- ====== WHAT'S NEW / FIRST VISIT MODAL ====== -->
<div id="newsOverlay" class="modalOverlay" role="dialog" aria-modal="true" aria-labelledby="newsTitle">
  <div class="modal">
    <h2 id="newsTitle">What’s new</h2>
    <div id="newsBody"></div>
    <div class="modalActions">
      <button id="newsPrimaryBtn">Continue</button>
    </div>
  </div>
</div>

  <!-- ====== HOW TO PLAY MODAL (reused for each game) ====== -->
  <div id="howToOverlay" class="modalOverlay" role="dialog" aria-modal="true" aria-labelledby="howToTitle">
    <div class="modal">
      <h2 id="howToTitle">How to play</h2>
      <div id="howToBody"></div>
      <div class="modalActions">
        <button id="howToStartBtn">Start Game</button>
      </div>
    </div>
  </div>

  <!-- ====== STACKS FINISH MODAL ====== -->
  <div id="finishOverlay" class="modalOverlay" role="dialog" aria-modal="true" aria-labelledby="finishTitle">
    <div class="modal">
      <h2 id="finishTitle">Stacks complete!</h2>
      <div id="finishBody"></div>
      <div class="modalActions">
        <button id="finishLeaderboardBtn">Leaderboard</button>
        <button id="finishHomeBtn">Home</button>
        <button id="finishPlayAgainBtn">Play again</button>
        <button id="finishCloseBtn">Close</button>
      </div>
    </div>
  </div>
  <div id="confettiLayer" class="confettiLayer" aria-hidden="true"></div>

  <script>
  // ====== CONFIG ======
  // Real spec: TARGET_SET_SIZE = 45, with 45 sets × 45 items.
  const TARGET_SET_SIZE = 5;
  const MAX_STACK_PREVIEW_ITEMS = 3;

// ====== VERSION / CHANGELOG (EDIT HERE) ======
const APP_VERSION = "beta v0.0.2";

const CHANGELOG_TITLE = "What’s new";
const CHANGELOG_ITEMS = [
  "The ability to put your name at the top of the page",
  "15 categories, with over 500 items",
  "Digital confetti when you win, because that's nice.",
  "Live leaderboard, see how well you do against everyone else",
  "v0.0.2 - added new board generation rules, should mean no repeats for 3 days minimum",
];

const CHANGELOG_SEEN_KEY = "puzzle_changelog_seen_version_v1";
const PLAYER_NAME_KEY = "puzzle_player_name_v1";

  // DEV / TESTING TOGGLES
  // Set to true to make each game's Reset button also forget the "How To Play" seen flag
  // and re-open the How To Play modal immediately.
  const RESET_RESETS_HOWTO = true;

  function shouldResetHowToOnReset() {
    return RESET_RESETS_HOWTO;
  }

  // Demo data (fallback if Supabase isn't configured)
  let sets = [
    { id: "setA", name: "Fruits" },
    { id: "setB", name: "Planets" },
    { id: "setC", name: "Instruments" },
    { id: "setD", name: "Fall Out Boy Tracks" },
    { id: "setE", name: "Doctor Who Episodes (2005-present)" },
    { id: "setF", name: "YMBBT 2024/25 Scenes" },
    { id: "setG", name: "Steven Spielberg Directed Films" },
    { id: "setH", name: "London Underground Stations" },
  ];

  let items = [
    ...["Apple","Pear","Mango","Plum","Grape"].map((label,i)=>({id:`A${i}`,label,setId:"setA"})),
    ...["Mars","Venus","Earth","Saturn","Neptune"].map((label,i)=>({id:`B${i}`,label,setId:"setB"})),
    ...["Piano","Cello","Flute","Drums","Harp"].map((label,i)=>({id:`C${i}`,label,setId:"setC"})),
    ...["I Don't Care","The Phoenix","Centuries","Uma Thurman","America's Suitehearts"].map((label,i)=>({id:`D${i}`,label,setId:"setD"})),
    ...["Rose","The Parting Of The Ways","Midnight","Blink","A Good Man Goes To War"].map((label,i)=>({id:`E${i}`,label,setId:"setE"})),
    ...["Reception","Leader","Gameshow","Sushi","Shower"].map((label,i)=>({id:`F${i}`,label,setId:"setF"})),
    ...["Jaws","Munich","Lincoln","Empire Of The Sun","The Colour Purple"].map((label,i)=>({id:`G${i}`,label,setId:"setG"})),
    ...["Fairlop","Bank","Golder's Green","Seven Sisters","Hammersmith"].map((label,i)=>({id:`H${i}`,label,setId:"setH"})),
  ];

  // ====== LOOKUPS ======
  let itemById = new Map();
  let setById = new Map();

  function rebuildLookups() {
    itemById = new Map(items.map(it => [it.id, it]));
    setById = new Map(sets.map(s => [s.id, s]));
  }
  rebuildLookups();
// ====== SUPABASE (STACKS ONLY) ======
// Paste your Supabase credentials here (Project Settings -> API)
const SUPABASE_URL = "https://aqhbglfghvuovowdxkus.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFxaGJnbGZnaHZ1b3Zvd2R4a3VzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njg2NDgzNDcsImV4cCI6MjA4NDIyNDM0N30.eAo28Ws6Gzep1LVVHPQwdz7eahOPpwIKMY0yI4teifs";

const supabaseClient = (SUPABASE_URL && SUPABASE_ANON_KEY && window.supabase)
  ? window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY)
  : null;

const DAILY_CATEGORY_COUNT = 4; // TEMP: show all current test categories

// Avoid repeats across recent days
const STACKS_NO_REPEAT_DAYS = 3; // do not repeat categories/items from the last N completed boards
const STACKS_REGEN_SALT_KEY = "stacks_regen_salt_v1";

function getRegenSaltForDay(dayKey) {
  try {
    const raw = localStorage.getItem(STACKS_REGEN_SALT_KEY);
    if (!raw) return { dayKey, salt: 0 };
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== "object") return { dayKey, salt: 0 };
    if (parsed.dayKey !== dayKey) return { dayKey, salt: 0 };
    return { dayKey, salt: Number(parsed.salt) || 0 };
  } catch {
    return { dayKey, salt: 0 };
  }
}

function bumpRegenSaltForDay(dayKey) {
  try {
    const cur = getRegenSaltForDay(dayKey);
    const next = { dayKey, salt: (Number(cur.salt) || 0) + 1 };
    localStorage.setItem(STACKS_REGEN_SALT_KEY, JSON.stringify(next));
    return next.salt;
  } catch {
    return 1;
  }
}

function normalizeLabelFallback(s) {
  return String(s || "")
    .toLowerCase()
    .trim()
    .replaceAll("&", "and")
    .replace(/[^a-z0-9 ]+/g, "")
    .replace(/\s+/g, " ");
}

// Deterministic PRNG helpers
function xmur3(str) {
  let h = 1779033703 ^ str.length;
  for (let i = 0; i < str.length; i++) {
    h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
    h = (h << 13) | (h >>> 19);
  }
  return function () {
    h = Math.imul(h ^ (h >>> 16), 2246822507);
    h = Math.imul(h ^ (h >>> 13), 3266489909);
    h ^= h >>> 16;
    return h >>> 0;
  };
}

function mulberry32(a) {
  return function () {
    let t = (a += 0x6D2B79F5);
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

function seededShuffle(arr, rand) {
  const a = arr.slice();
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(rand() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

async function loadStacksFromSupabaseDaily() {
  if (!supabaseClient) return { ok: false, reason: "supabase not configured" };

  // Fetch active categories
  const { data: cats, error: catsErr } = await supabaseClient
    .from("stacks_categories")
    .select("id,name,primary_tag")
    .eq("active", true);

  if (catsErr) return { ok: false, reason: catsErr.message };

  // Fetch active items
  const { data: its, error: itsErr } = await supabaseClient
    .from("stacks_items")
    .select("id,category_id,label,label_norm")
    .eq("active", true);

  if (itsErr) return { ok: false, reason: itsErr.message };

  const itemsByCat = new Map();
  for (const it of its || []) {
    const k = it.category_id;
    if (!itemsByCat.has(k)) itemsByCat.set(k, []);
    itemsByCat.get(k).push(it);
  }

  // Only categories that can supply TARGET_SET_SIZE items
  // ====== Avoid repeats across recent days ======
  // Build recent-history exclusions (categories + items) so boards don't feel repetitive.
  let recentCategoryIds = new Set();
  let recentItemIds = new Set();
  let recentItemNorms = new Set();

  try {
    const today = new Date();
    const days = Math.max(0, Math.floor(STACKS_NO_REPEAT_DAYS || 0));
    if (days > 0) {
      // Fetch recent boards by most recent date_key.
      const { data: recentBoards, error: recentErr } = await supabaseClient
        .from("daily_stacks_boards")
        .select("date_key,category_ids,item_ids")
        .order("date_key", { ascending: false })
        .limit(days);

      if (!recentErr && Array.isArray(recentBoards)) {
        for (const b of recentBoards) {
          // Skip today if present (shouldn't be, since we already checked)
          if (b?.date_key === dayKey) continue;

          if (Array.isArray(b?.category_ids)) {
            for (const cid of b.category_ids) recentCategoryIds.add(cid);
          }
          if (Array.isArray(b?.item_ids)) {
            for (const iid of b.item_ids) recentItemIds.add(iid);
          }
        }
      }
    }
  } catch (e) {
    console.warn("Stacks: recent-history fetch failed:", e);
  }

  // Convert recent item ids to recent norms (best-effort)
  try {
    if (recentItemIds.size) {
      const itemMapForNorms = new Map((its || []).map(i => [i.id, i]));
      for (const iid of recentItemIds) {
        const it = itemMapForNorms.get(iid);
        if (!it) continue;
        const n = (it.label_norm || "").trim() || normalizeLabelFallback(it.label);
        if (n) recentItemNorms.add(n);
      }
    }
  } catch {}

  // Exclude recently used categories (unless we don't have enough)
  const eligibleCats = (cats || [])
    .filter(c => (itemsByCat.get(c.id) || []).length >= TARGET_SET_SIZE)
    // Avoid categories used on recent boards (unless we don't have enough)
    .filter(c => !recentCategoryIds.has(c.id))
    .sort((a, b) => String(a.id).localeCompare(String(b.id)));

  // If exclusion makes the pool too small, relax category exclusion (but keep item exclusion later)
  const minNeedCats = Math.min(DAILY_CATEGORY_COUNT, (cats || []).length);
  const relaxedCats = (cats || [])
    .filter(c => (itemsByCat.get(c.id) || []).length >= TARGET_SET_SIZE)
    .sort((a, b) => String(a.id).localeCompare(String(b.id)));

  const catPool = (eligibleCats.length >= minNeedCats) ? eligibleCats : relaxedCats;
  if (catPool.length === 0) return { ok: false, reason: "no eligible categories" };

  const dayKey = londonDateKey();

// Preferred: stored daily board so everyone gets the exact same categories + items.
// Table: daily_stacks_boards(date_key date pk, category_ids uuid[], item_ids uuid[], signature text)
try {
  const { data: boardRow, error: boardErr } = await supabaseClient
    .from("daily_stacks_boards")
    .select("date_key,category_ids,item_ids,signature,board_num")
    .eq("date_key", dayKey)
    .maybeSingle();

  if (!boardErr && boardRow && Array.isArray(boardRow.category_ids) && Array.isArray(boardRow.item_ids)) {
    const catMap = new Map((cats || []).map(c => [c.id, c]));
    const itemMap = new Map((its || []).map(i => [i.id, i]));

    const nextSets = boardRow.category_ids
      .map(cid => catMap.get(cid))
      .filter(Boolean)
      .map(c => ({ id: c.id, name: c.name, tag: c.primary_tag }));

    const allowedCats = new Set(nextSets.map(s => s.id));

    const nextItems = boardRow.item_ids
      .map(iid => itemMap.get(iid))
      .filter(it => it && allowedCats.has(it.category_id))
      .map(it => ({ id: it.id, label: it.label, setId: it.category_id }));

    if (nextSets.length && nextItems.length) {
      sets = nextSets;
      items = nextItems;
      rebuildLookups();

      const sig =
        boardRow.signature ||
        `${dayKey}|${nextSets.map(s => s.id).join(",")}|${nextItems.map(i => i.id).join(",")}`;

        return { ok: true, signature: sig, dayKey, boardNum: boardRow.board_num ?? null };
    }
  }
} catch {
  // Table may not exist yet; fall through to deterministic generation.
}

// No stored board: generate a fresh RANDOM board, then insert once for the day.
// So if you delete the Supabase row during testing, the next load produces a new board.
const genNonce = (crypto?.randomUUID ? crypto.randomUUID() : (String(Math.random()).slice(2) + Date.now()));

const shuffledCats = shuffleOnce(catPool);

  const usedNorms = new Set(recentItemNorms);
  const nextSets = [];
  const nextItems = [];

  for (const c of shuffledCats) {
    if (nextSets.length >= Math.min(DAILY_CATEGORY_COUNT, catPool.length)) break;

    const pool = (itemsByCat.get(c.id) || [])
  .slice()
  .sort((a, b) => String(a.id).localeCompare(String(b.id)))
  .map(x => ({
    id: x.id,
    label: x.label,
    norm: (x.label_norm || "").trim() || normalizeLabelFallback(x.label),
  }));

    // Filter out norms already used today OR on recent boards, and avoid recently-used item ids
    const cleanPool = pool.filter(p => p.norm && !usedNorms.has(p.norm) && !recentItemIds.has(p.id));
    if (cleanPool.length < TARGET_SET_SIZE) continue;

// Randomly choose items from this category
const chosen = shuffleOnce(cleanPool).slice(0, TARGET_SET_SIZE);

    // Register
    nextSets.push({ id: c.id, name: c.name, tag: c.primary_tag });
    for (const it of chosen) {
      nextItems.push({ id: it.id, label: it.label, setId: c.id });
      usedNorms.add(it.norm);
    }
  }

  if (nextSets.length === 0 || nextItems.length === 0) {
    return { ok: false, reason: "could not assemble daily board" };
  }

  // Apply
  // Build a signature so we can reset saved state when the daily selection changes
  const sig = `${dayKey}|nonce:${genNonce}|${nextSets.map(s => s.id).join(",")}|${nextItems.map(i => i.id).join(",")}`;

// Try to persist this daily board so everyone sees the same one.
// If another client inserts first, we re-read the stored row and use it.
try {
  const { data: insData, error: insErr } = await supabaseClient
    .from("daily_stacks_boards")
    .insert([{
      date_key: dayKey,
      category_ids: nextSets.map(s => s.id),
      item_ids: nextItems.map(i => i.id),
      signature: sig,
      regenerated_at: new Date().toISOString(),
    }])
    .select("board_num")
    .maybeSingle();

  insertedBoardNum = insData?.board_num ?? null;

  if (insErr) {
    const msg = String(insErr.message || "").toLowerCase();
    if (msg.includes("duplicate") || msg.includes("23505")) {
      const { data: boardRow2 } = await supabaseClient
        .from("daily_stacks_boards")
        .select("date_key,category_ids,item_ids,signature")
        .eq("date_key", dayKey)
        .maybeSingle();

      if (boardRow2 && Array.isArray(boardRow2.category_ids) && Array.isArray(boardRow2.item_ids)) {
        const catMap = new Map((cats || []).map(c => [c.id, c]));
        const itemMap = new Map((its || []).map(i => [i.id, i]));

        const storedSets = boardRow2.category_ids
          .map(cid => catMap.get(cid))
          .filter(Boolean)
          .map(c => ({ id: c.id, name: c.name, tag: c.primary_tag }));

        const allowedCats = new Set(storedSets.map(s => s.id));
        const storedItems = boardRow2.item_ids
          .map(iid => itemMap.get(iid))
          .filter(it => it && allowedCats.has(it.category_id))
          .map(it => ({ id: it.id, label: it.label, setId: it.category_id }));

        if (storedSets.length && storedItems.length) {
          sets = storedSets;
          items = storedItems;
          rebuildLookups();
          const sig2 = boardRow2.signature || sig;
          return { ok: true, signature: sig, dayKey, boardNum: insertedBoardNum };
        }
      }
    } else {
      console.warn("Stacks: could not persist daily board:", insErr);
    }
  }
} catch {}

// Apply our generated board
sets = nextSets;
items = nextItems;
rebuildLookups();

return { ok: true, signature: sig, dayKey, boardNum: insertedBoardNum };
}

// Cache today's board locally so mobile resets can work even if Supabase is slow/offline.
const STACKS_DAILY_CACHE_KEY = "stacks_daily_cache_v2";
let stacksLoadPromise = null;

let insertedBoardNum = null;

function cacheStacksDailyBoard(dayKey, signature) {
  try {
    const payload = {
      dayKey,
      signature,
      boardNum: stacksBoardNum,
      sets,
      items,
      cachedAt: Date.now(),
    };
    localStorage.setItem(STACKS_DAILY_CACHE_KEY, JSON.stringify(payload));
  } catch {}
}

function loadStacksDailyBoardFromCache(dayKey) {
  try {
    const raw = localStorage.getItem(STACKS_DAILY_CACHE_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    if (!parsed || parsed.dayKey !== dayKey) return null;
    if (!Array.isArray(parsed.sets) || !Array.isArray(parsed.items)) return null;
    return parsed;
  } catch {
    return null;
  }
}

async function ensureStacksBoardReady() {
  // Single-flight: if multiple actions trigger load, reuse the same promise.
  if (stacksLoadPromise) return stacksLoadPromise;

  stacksLoadPromise = (async () => {
    const today = londonDateKey();

    // 1) Try Supabase
    try {
      const res = await loadStacksFromSupabaseDaily();
      if (res && res.ok) {
        // keep signature for mismatch detection
        if (res.boardNum !== undefined) stacksBoardNum = res.boardNum ?? null;
        cacheStacksDailyBoard(res.dayKey || today, res.signature || "");
        setBoardSourceLabel("supabase", res.boardNum ?? null);
        return { ok: true, source: "supabase", signature: res.signature || "", dayKey: res.dayKey || today };
      }
      // fall through to cache
      console.warn("Stacks: Supabase daily load failed:", res?.reason || res);
    } catch (e) {
      console.warn("Stacks: Supabase daily load threw:", e);
    }

    // 2) Try cache for today
    const cached = loadStacksDailyBoardFromCache(today);
    if (cached) {
      sets = cached.sets;
      items = cached.items;
      if (cached.boardNum !== undefined) stacksBoardNum = cached.boardNum;
      setBoardSourceLabel("cache", cached.boardNum ?? null);
      rebuildLookups();
      return { ok: true, source: "cache", signature: cached.signature || "", dayKey: cached.dayKey || today };
    }

    // 3) Nothing worked — leave demo data in place
    setBoardSourceLabel("demo");
    return { ok: false, source: "demo", signature: "", dayKey: today };
  })();

  return stacksLoadPromise;
}

  // ====== PERSISTENCE ======
  const STORAGE_KEY = "stacks_puzzle_state_v1";
  // Signature for the currently loaded daily Stacks board (used to invalidate saved state)
const STACKS_SIGNATURE_KEY = "stacks_puzzle_signature_v1";

function getOrCreateDeviceId() {
  try {
    const existing = localStorage.getItem(DEVICE_ID_KEY);
    if (existing) return existing;
    const id = (crypto?.randomUUID ? crypto.randomUUID() : String(Math.random()).slice(2) + Date.now());
    localStorage.setItem(DEVICE_ID_KEY, id);
    return id;
  } catch {
    return "";
  }
}

function hasRemoteLeaderboard() {
  return !!supabaseClient; // uses the already-configured client
}

async function submitRunRemote(row) {
  if (!hasRemoteLeaderboard()) return;
  try {
    const payload = { ...row };
    // Server generates date_key from created_at (London), so do not send date_key.
    delete payload.date_key;
    delete payload.dateKey;

    const { error } = await supabaseClient
      .from("leaderboard_runs")
      .insert([payload]);

    if (error) console.warn("Leaderboard insert failed:", error);
  } catch (e) {
    console.warn("Leaderboard insert failed:", e);
  }
}

async function fetchRunsTodayRemote(game, dayKey, limit = 30) {
  if (!hasRemoteLeaderboard()) return null;

  let q = supabaseClient
    .from("leaderboard_runs")
    .select("game,name,time_ms,mistakes,correct_links,total_error,created_at,date_key")
    .eq("game", game)
    .eq("date_key", dayKey);

  if (game === "numerate") {
    q = q.order("total_error", { ascending: true, nullsFirst: false })
         .order("time_ms", { ascending: true, nullsFirst: false });
  } else {
    q = q.order("time_ms", { ascending: true, nullsFirst: false })
         .order("mistakes", { ascending: true, nullsFirst: false });
  }

  q = q.order("created_at", { ascending: true }).limit(limit);

  const { data, error } = await q;
  if (error) throw error;

  return (data || []).map(r => ({
    name: r.name,
    timeMs: r.time_ms ?? 0,
    mistakes: r.mistakes ?? 0,
    correctLinks: r.correct_links ?? 0,
    totalError: r.total_error ?? 0,
    createdAt: r.created_at ? new Date(r.created_at).getTime() : Date.now(),
    dateKey: r.date_key || dayKey,
  }));
}

async function fetchRecentRunsRemote(game, limit = 1000) {
  if (!hasRemoteLeaderboard()) return null;

  const { data, error } = await supabaseClient
    .from("leaderboard_runs")
    .select("game,name,time_ms,mistakes,correct_links,total_error,created_at,date_key")
    .eq("game", game)
    .order("created_at", { ascending: false })
    .limit(limit);

  if (error) throw error;

  return (data || []).map(r => ({
    name: r.name,
    timeMs: r.time_ms ?? 0,
    mistakes: r.mistakes ?? 0,
    correctLinks: r.correct_links ?? 0,
    totalError: r.total_error ?? 0,
    createdAt: r.created_at ? new Date(r.created_at).getTime() : Date.now(),
    dateKey: r.date_key || "",
  }));
}

function londonDateKey(d = new Date()) {
  const parts = new Intl.DateTimeFormat("en-CA", {
    timeZone: "Europe/London",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
  }).formatToParts(d);
  const y = parts.find(p => p.type === "year")?.value;
  const m = parts.find(p => p.type === "month")?.value;
  const day = parts.find(p => p.type === "day")?.value;
  return `${y}-${m}-${day}`;
}

function tzOffsetMinutes(date, timeZone) {
  const parts = new Intl.DateTimeFormat("en-GB", {
    timeZone,
    timeZoneName: "shortOffset",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
  }).formatToParts(date);

  const tz = parts.find(p => p.type === "timeZoneName")?.value || "GMT";
  const m = tz.match(/GMT([+-]\d{1,2})(?::(\d{2}))?/i);
  if (!m) return 0;
  const sign = m[1].startsWith("-") ? -1 : 1;
  const hh = Math.abs(parseInt(m[1], 10));
  const mm = m[2] ? parseInt(m[2], 10) : 0;
  return sign * (hh * 60 + mm);
}

function msUntilNextLondonMidnight(now = new Date()) {
  const tz = "Europe/London";

  // Get today's London calendar date and add 1 day (calendar-safe)
  const todayKey = londonDateKey(now); // YYYY-MM-DD in London
  const [yy, mm, dd] = todayKey.split("-").map(Number);

  // Advance one calendar day (in UTC) based on the London date key
  const d = new Date(Date.UTC(yy, mm - 1, dd, 12, 0, 0)); // midday avoids DST weirdness
  d.setUTCDate(d.getUTCDate() + 1);
  const ty = d.getUTCFullYear();
  const tm = d.getUTCMonth() + 1;
  const td = d.getUTCDate();

  // Target is London 00:00 at start of (ty-tm-td).
  // Convert that local time to UTC by subtracting London offset at that instant.
  const guessUtc = Date.UTC(ty, tm - 1, td, 0, 0, 0);
  const off0 = tzOffsetMinutes(new Date(guessUtc), tz);
  let targetUtc = guessUtc - off0 * 60 * 1000;

  // One refinement pass for DST boundary at midnight
  const off1 = tzOffsetMinutes(new Date(targetUtc), tz);
  if (off1 !== off0) targetUtc = guessUtc - off1 * 60 * 1000;

  return Math.max(0, targetUtc - now.getTime());
}

function fmtHMS(ms) {
  const total = Math.max(0, Math.floor(ms / 1000));
  const h = Math.floor(total / 3600);
  const m = Math.floor((total % 3600) / 60);
  const s = total % 60;
  return `${String(h).padStart(2,"0")}:${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`;
}

function setVersionBadges() {
  const ids = [
    "versionBadgeHome",
    "versionBadgeStacks",
    "versionBadgeNumerate",
    "versionBadgeTimeline",
    "versionBadgeLB",
  ];
  for (const id of ids) {
    const el = document.getElementById(id);
    if (el) el.textContent = APP_VERSION;
  }
}

// ====== WHAT'S NEW / FIRST VISIT MODAL ======
const newsOverlay = document.getElementById("newsOverlay");
const newsTitle = document.getElementById("newsTitle");
const newsBody = document.getElementById("newsBody");
const newsPrimaryBtn = document.getElementById("newsPrimaryBtn");

function openNewsModal() {
  if (!newsOverlay) return;
  newsOverlay.classList.add("active");
  document.body.classList.add("modal-open");
  setTimeout(() => newsPrimaryBtn?.focus(), 0);
}

function closeNewsModal() {
  if (!newsOverlay) return;
  newsOverlay.classList.remove("active");
  document.body.classList.remove("modal-open");
}

function changelogHtml() {
  const items = (CHANGELOG_ITEMS || []).map(x => `<li>${escapeHtml(x)}</li>`).join("");
  return `
    <p class="muted">${escapeHtml(APP_VERSION)}</p>
    <ul>${items}</ul>
  `;
}

function ensurePlayerNameWired() {
  const input = document.getElementById("playerName");
  if (!input) return;

  // Load existing
  try {
    const existing = (localStorage.getItem(PLAYER_NAME_KEY) || "").trim();
    if (existing && !input.value) input.value = existing;
  } catch {}

  // Save on input (bind once)
  if (!input.dataset.boundName) {
    input.dataset.boundName = "1";
    input.addEventListener("input", () => {
      const v = (input.value || "").trim();
      try { localStorage.setItem(PLAYER_NAME_KEY, v); } catch {}
    });
  }
}

function maybePromptNameFirstVisit() {
  ensurePlayerNameWired();

  let existing = "";
  try { existing = (localStorage.getItem(PLAYER_NAME_KEY) || "").trim(); } catch {}
  if (existing) return false;

  if (newsTitle) newsTitle.textContent = "Pick a name";
  if (newsBody) {
    newsBody.innerHTML = `
      <p>This is what shows on the leaderboard.</p>
      <div style="margin:10px 0 6px;">
        <label for="newsNameInput" style="display:block; font-size:13px; opacity:0.85; margin-bottom:6px;">Name</label>
        <input id="newsNameInput" class="textInput" type="text" placeholder="Kay" autocomplete="nickname" style="width:100%; box-sizing:border-box;" />
      </div>
      <p class="muted" style="margin-top:8px;">You can change this later on the home screen.</p>
    `;
  }
  if (newsPrimaryBtn) newsPrimaryBtn.textContent = "Save name";

  // Wire the modal input
  const commit = () => {
    const inputEl = document.getElementById("newsNameInput");
    const v = (inputEl?.value || "").trim();
    if (!v) {
      inputEl?.focus();
      return;
    }
    try { localStorage.setItem(PLAYER_NAME_KEY, v); } catch {}

    // Also reflect into the home input if present
    const homeInput = document.getElementById("playerName");
    if (homeInput) homeInput.value = v;

    closeNewsModal();
  };

  newsPrimaryBtn.onclick = commit;

  openNewsModal();

  // Focus and allow Enter-to-save
  setTimeout(() => {
    const inputEl = document.getElementById("newsNameInput");
    inputEl?.focus();
    if (inputEl && !inputEl.dataset.boundEnter) {
      inputEl.dataset.boundEnter = "1";
      inputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") commit();
      });
    }
  }, 50);

  return true;
}

function maybeShowChangelogOncePerVersion() {
  let seen = "";
  try { seen = localStorage.getItem(CHANGELOG_SEEN_KEY) || ""; } catch {}
  if (seen === APP_VERSION) return false;

  try { localStorage.setItem(CHANGELOG_SEEN_KEY, APP_VERSION); } catch {}

  if (newsTitle) newsTitle.textContent = CHANGELOG_TITLE || "What’s new";
  if (newsBody) newsBody.innerHTML = changelogHtml();
  if (newsPrimaryBtn) newsPrimaryBtn.textContent = "Continue";

  newsPrimaryBtn.onclick = () => closeNewsModal();
  openNewsModal();
  return true;
}

// ====== LEADERBOARD KEYS ======
// Local leaderboard storage
const LB_KEY = "puzzle_arcade_leaderboard_v1";
// Per-device id used for shared leaderboard submissions
const DEVICE_ID_KEY = "puzzle_device_id_v1";

// Current leaderboard filters
let leaderboardMode = "today";      // "today" | "all"
let leaderboardGame = "stacks";     // "stacks" | "numerate"

function getPlayerName() {
  let n = "";
  try { n = localStorage.getItem(PLAYER_NAME_KEY) || ""; } catch {}
  return n.trim() || "Anonymous";
}

function loadLeaderboard() {
  try {
    const raw = localStorage.getItem(LB_KEY);
    if (!raw) return { stacks: {}, numerate: {} };
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== "object") return { stacks: {}, numerate: {} };
    parsed.stacks ??= {};
    parsed.numerate ??= {};
    return parsed;
  } catch {
    return { stacks: {}, numerate: {} };
  }
}

function saveLeaderboard(lb) {
  localStorage.setItem(LB_KEY, JSON.stringify(lb));
}

function clearLeaderboard() {
  localStorage.removeItem(LB_KEY);
}

function submitStacksRun(result) {
  // local fallback
  const lb = loadLeaderboard();
  const day = result.dateKey;
  lb.stacks[day] ??= [];
  lb.stacks[day].push(result);
  lb.stacks[day] = lb.stacks[day].slice(-200); // cap growth
  saveLeaderboard(lb);

  // remote
  const row = {
    game: "stacks",
    name: result.name,
    time_ms: Math.max(0, Math.floor(result.timeMs || 0)),
    mistakes: Math.max(0, Math.floor(result.mistakes || 0)),
    correct_links: Math.max(0, Math.floor(result.correctLinks || 0)),
    device_id: getOrCreateDeviceId(),
    puzzle_sig: localStorage.getItem(STACKS_SIGNATURE_KEY) || null,
  };
  // Fire-and-forget
  submitRunRemote(row);
}

function submitNumerateRun(result) {
  // local fallback
  const lb = loadLeaderboard();
  const day = result.dateKey;
  lb.numerate[day] ??= [];
  lb.numerate[day].push(result);
  lb.numerate[day] = lb.numerate[day].slice(-200);
  saveLeaderboard(lb);

  // remote
  const row = {
    game: "numerate",
    name: result.name,
    total_error: Number.isFinite(result.totalError) ? result.totalError : null,
    time_ms: Math.max(0, Math.floor(result.timeMs || 0)),
    device_id: getOrCreateDeviceId(),
    puzzle_sig: `numerate|${londonDateKey()}`,
  };
  submitRunRemote(row);
}

function sortNumerateRuns(runs) {
  return runs.slice().sort((a, b) =>
    (a.totalError - b.totalError) ||
    (a.timeMs - b.timeMs) ||
    (a.createdAt - b.createdAt)
  );
}

function fmtSeconds(ms) {
  return `${(ms / 1000).toFixed(1)}s`;
}

function sortStacksRuns(runs) {
  return runs.slice().sort((a, b) =>
    (a.timeMs - b.timeMs) ||
    (a.mistakes - b.mistakes) ||
    (a.createdAt - b.createdAt)
  );
}

function renderLeaderboard(mode = "today") {
  // wrapper so callers don't need await
  renderLeaderboardAsync(mode);
}

async function renderLeaderboardAsync(mode = "today") {
  const el = document.getElementById("leaderboardContent");
  if (!el) return;

  // Disable the clear button when using a shared leaderboard (we can't delete remote rows)
  const clearBtn = document.getElementById("lbClear");
  if (clearBtn) {
    if (hasRemoteLeaderboard()) {
      clearBtn.disabled = true;
      clearBtn.title = "Shared leaderboard is enabled; clearing is disabled.";
    } else {
      clearBtn.disabled = false;
      clearBtn.title = "Deletes local leaderboard only";
    }
  }

  el.innerHTML = `<div class="muted">Loading…</div>`;

  const lb = loadLeaderboard();
  const byDayStacks = lb.stacks || {};
  const byDayNumerate = lb.numerate || {};

  const day = londonDateKey();

  try {
    // TODAY
    if (mode === "today") {
      if (leaderboardGame === "numerate") {
        const remote = hasRemoteLeaderboard() ? await fetchRunsTodayRemote("numerate", day, 30) : null;
        const runs = remote ?? sortNumerateRuns(byDayNumerate[day] || []);

        if (!runs || runs.length === 0) {
          el.innerHTML = `<div class="muted">No Numerate runs saved for ${escapeHtml(day)} yet.</div>`;
          return;
        }

        el.innerHTML = `
          <div class="hint" style="margin-bottom:10px;">Numerate — ${escapeHtml(day)}</div>
          <table>
            <thead>
              <tr>
                <th>#</th><th>Name</th><th>Total error</th><th>Time used</th><th class="muted">Submitted</th>
              </tr>
            </thead>
            <tbody>
              ${runs.slice(0, 30).map((r, idx) => {
                const when = new Date(r.createdAt);
                const whenStr = new Intl.DateTimeFormat("en-GB", {
                  timeZone: "Europe/London",
                  hour: "2-digit",
                  minute: "2-digit",
                }).format(when);
                return `
                  <tr>
                    <td class="mono">${idx + 1}</td>
                    <td>${escapeHtml(r.name)}</td>
                    <td class="mono">${escapeHtml(Number(r.totalError).toFixed(2))}</td>
                    <td class="mono">${escapeHtml(fmtSeconds(r.timeMs))}</td>
                    <td class="muted mono">${escapeHtml(whenStr)}</td>
                  </tr>
                `;
              }).join("")}
            </tbody>
          </table>
        `;
        return;
      }

      // default: stacks
      const remote = hasRemoteLeaderboard() ? await fetchRunsTodayRemote("stacks", day, 30) : null;
      const runs = remote ?? sortStacksRuns(byDayStacks[day] || []);

      if (!runs || runs.length === 0) {
        el.innerHTML = `<div class="muted">No Stacks runs saved for ${escapeHtml(day)} yet.</div>`;
        return;
      }

      el.innerHTML = `
        <div class="hint" style="margin-bottom:10px;">Stacks — ${escapeHtml(day)}</div>
        <table>
          <thead>
            <tr>
              <th>#</th><th>Name</th><th>Time</th><th>Mistakes</th><th class="muted">Submitted</th>
            </tr>
          </thead>
          <tbody>
            ${runs.slice(0, 30).map((r, idx) => {
              const when = new Date(r.createdAt);
              const whenStr = new Intl.DateTimeFormat("en-GB", {
                timeZone: "Europe/London",
                hour: "2-digit",
                minute: "2-digit",
              }).format(when);
              return `
                <tr>
                  <td class="mono">${idx + 1}</td>
                  <td>${escapeHtml(r.name)}</td>
                  <td class="mono">${escapeHtml(fmtTime(r.timeMs))}</td>
                  <td class="mono">${escapeHtml(String(r.mistakes))}</td>
                  <td class="muted mono">${escapeHtml(whenStr)}</td>
                </tr>
              `;
            }).join("")}
          </tbody>
        </table>
      `;
      return;
    }

    // ALL-TIME (best per person)
    let allRuns = null;
    if (hasRemoteLeaderboard()) {
      allRuns = await fetchRecentRunsRemote(leaderboardGame, 1000);
    }

    if (!allRuns) {
      allRuns = (leaderboardGame === "numerate")
        ? Object.values(byDayNumerate).flat()
        : Object.values(byDayStacks).flat();
    }

    if (!allRuns || allRuns.length === 0) {
      el.innerHTML = `<div class="muted">No ${leaderboardGame === "numerate" ? "Numerate" : "Stacks"} runs saved yet.</div>`;
      return;
    }

    const bestByName = new Map();
    for (const r of allRuns) {
      const key = (r.name || "Anonymous").trim() || "Anonymous";
      const prev = bestByName.get(key);
      if (!prev) bestByName.set(key, r);
      else {
        if (leaderboardGame === "numerate") {
          const better = (r.totalError < prev.totalError) || (r.totalError === prev.totalError && r.timeMs < prev.timeMs);
          if (better) bestByName.set(key, r);
        } else {
          const better = (r.timeMs < prev.timeMs) || (r.timeMs === prev.timeMs && r.mistakes < prev.mistakes);
          if (better) bestByName.set(key, r);
        }
      }
    }

    const bestRows = (leaderboardGame === "numerate")
      ? sortNumerateRuns(Array.from(bestByName.values()))
      : sortStacksRuns(Array.from(bestByName.values()));

    if (leaderboardGame === "numerate") {
      el.innerHTML = `
        <div class="hint" style="margin-bottom:10px;">Numerate — All-time best</div>
        <table>
          <thead>
            <tr>
              <th>#</th><th>Name</th><th>Best error</th><th>Best time</th><th class="muted">Day</th>
            </tr>
          </thead>
          <tbody>
            ${bestRows.slice(0, 30).map((r, idx) => `
              <tr>
                <td class="mono">${idx + 1}</td>
                <td>${escapeHtml(r.name)}</td>
                <td class="mono">${escapeHtml(Number(r.totalError).toFixed(2))}</td>
                <td class="mono">${escapeHtml(fmtSeconds(r.timeMs))}</td>
                <td class="muted mono">${escapeHtml(r.dateKey || "")}</td>
              </tr>
            `).join("")}
          </tbody>
        </table>
      `;
      return;
    }

    el.innerHTML = `
      <div class="hint" style="margin-bottom:10px;">Stacks — All-time best</div>
      <table>
        <thead>
          <tr>
            <th>#</th><th>Name</th><th>Best time</th><th>Best mistakes</th><th class="muted">Day</th>
          </tr>
        </thead>
        <tbody>
          ${bestRows.slice(0, 30).map((r, idx) => `
            <tr>
              <td class="mono">${idx + 1}</td>
              <td>${escapeHtml(r.name)}</td>
              <td class="mono">${escapeHtml(fmtTime(r.timeMs))}</td>
              <td class="mono">${escapeHtml(String(r.mistakes))}</td>
              <td class="muted mono">${escapeHtml(r.dateKey || "")}</td>
            </tr>
          `).join("")}
        </tbody>
      </table>
    `;
  } catch (e) {
    console.warn("Leaderboard load failed:", e);
    el.innerHTML = `<div class="muted">Couldn’t load shared leaderboard. Falling back to local.</div>`;

    // fallback to local for the requested view
    if (mode === "today") {
      if (leaderboardGame === "numerate") {
        const runs = sortNumerateRuns((byDayNumerate[day] || []));
        if (!runs.length) { el.innerHTML = `<div class="muted">No Numerate runs saved for ${escapeHtml(day)} yet.</div>`; return; }
        el.innerHTML = `<div class="hint" style="margin-bottom:10px;">Numerate — ${escapeHtml(day)}</div>`;
        return;
      }
      const runs = sortStacksRuns((byDayStacks[day] || []));
      if (!runs.length) { el.innerHTML = `<div class="muted">No Stacks runs saved for ${escapeHtml(day)} yet.</div>`; return; }
      el.innerHTML = `<div class="hint" style="margin-bottom:10px;">Stacks — ${escapeHtml(day)}</div>`;
      return;
    }

    el.innerHTML = `<div class="muted">No local all-time data to show.</div>`;
  }
}

  function saveState() {
    // Don’t persist selection highlight; it’s annoying after refresh.
    const toSave = { ...state, selectedNodeId: null };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(toSave));
  }

  function loadState() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!parsed || !Array.isArray(parsed.nodes)) return null;

      // Ensure required fields exist
      parsed.selectedNodeId = null;
      parsed.correctLinks ??= 0;
      parsed.mistakes ??= 0;
      parsed.completedSets ??= 0;
      parsed.searchQuery ??= "";

      // Timer fields
      parsed.hasStarted ??= false;
      parsed.timerRunning ??= false;
      parsed.startMs ??= null;
      parsed.elapsedMs ??= 0;
      parsed.hasSubmittedWin ??= false;
      parsed.showWinModal ??= false;
      parsed.winModalDismissed ??= false;
      parsed.winCelebrated ??= false;

      return parsed;
    } catch {
      return null;
    }
  }

  function clearSavedState() {
    localStorage.removeItem(STORAGE_KEY);
  }

  // ====== STATE ======
  let state;
let timerInterval = null;

let stacksBoardSource = "demo"; // "supabase" | "cache" | "demo"
let stacksBoardNum = null;      // optional numeric id from Supabase

function setBoardSourceLabel(src, boardNum = null) {
  stacksBoardSource = src || "demo";
  if (boardNum !== undefined && boardNum !== null) stacksBoardNum = boardNum;

  const el = document.getElementById("boardSource");
  if (!el) return;

  const base = String(stacksBoardSource).toUpperCase();
  el.textContent = (stacksBoardNum !== null && stacksBoardNum !== undefined)
    ? `${base} #${stacksBoardNum}`
    : base;
}

  function shuffleOnce(arr) {
    const a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  function freshState() {
    // Randomize ONCE at reset (optional). Then stable ordering afterwards.
    const initial = shuffleOnce(items).map((it, idx) => ({
      nodeId: crypto.randomUUID(),
      type: "stack",
      setId: it.setId,
      itemIds: [it.id],
      order: idx, // board position key
    }));

    return {
      nodes: initial,
      selectedNodeId: null,
      correctLinks: 0,
      mistakes: 0,
      completedSets: 0,
      searchQuery: "",

      // Timer: starts on FIRST click
      hasStarted: false,
      timerRunning: false,
      startMs: null,
      elapsedMs: 0,
      hasSubmittedWin: false,
      showWinModal: false,
      winModalDismissed: false,
      winCelebrated: false,
    };
  }

  function getNode(nodeId) {
    return state.nodes.find(n => n.nodeId === nodeId);
  }

  function escapeHtml(str) {
    return String(str)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  // ====== TIMER ======
  function fmtTime(ms) {
    const total = Math.floor(ms / 1000);
    const m = Math.floor(total / 60);
    const s = total % 60;
    return `${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`;
  }

  function stopTicking() {
    if (timerInterval) clearInterval(timerInterval);
    timerInterval = null;
  }

  function startTicking() {
    stopTicking();
    timerInterval = setInterval(() => {
      if (!state.hasStarted || !state.timerRunning || !state.startMs) return;
      const shown = state.elapsedMs + (Date.now() - state.startMs);
      document.getElementById("timer").textContent = fmtTime(shown);
      setBoardSourceLabel(stacksBoardSource, stacksBoardNum);
    }, 250);
  }

  function startTimerIfNeeded() {
  if (!state) return;
  if (state.hasStarted) return;
  state.hasStarted = true;
  state.timerRunning = true;
  state.startMs = Date.now();
  saveState();
  startTicking();
}

function freezeTimer() {
  if (!state) return;
  if (!state.hasStarted || !state.timerRunning || !state.startMs) return;
  state.elapsedMs += (Date.now() - state.startMs);
  state.timerRunning = false;
  state.startMs = null;
  saveState();
  stopTicking();
}

  function resumeTimerIfRunning() {
    if (!state) return;
    if (!state.hasStarted) {
      document.getElementById("timer").textContent = "00:00";
      stopTicking();
      return;
    }

    if (!state.timerRunning) {
      document.getElementById("timer").textContent = fmtTime(state.elapsedMs);
      stopTicking();
      return;
    }

    // Was running before refresh; continue from now.
    state.startMs = Date.now();
    saveState();
    startTicking();
  }

  // ====== HELPERS ======
  function normalize(s) {
    return String(s || "").toLowerCase().trim();
  }

  function nodeMatchesSearch(node, qNorm) {
    if (!qNorm) return true;
    if (node.type !== "stack") return true; // always keep completed blocks visible

    // Always keep multi-item stacks visible so you can merge them while searching
    if (node.itemIds.length > 1) return true;

    // Single-item stack: match the item label
    const it = itemById.get(node.itemIds[0]);
    return normalize(it?.label).includes(qNorm);
  }

  function applyTransientClass(el, cls, durationMs = 220) {
    if (!el) return;
    el.classList.remove(cls);
    // Force reflow so animation restarts
    void el.offsetWidth;
    el.classList.add(cls);
    window.setTimeout(() => {
      el.classList.remove(cls);
    }, durationMs);
  }

  function flashNode(nodeId, cls) {
    const el = document.querySelector(`[data-node-id="${nodeId}"]`);
    if (!el) return;
    el.classList.remove("flash-green", "flash-red");
    void el.offsetWidth;
    el.classList.add(cls);
    applyTransientClass(el, "shake", 170);
  }

  function flashPill(pillId, cls) {
    const el = document.getElementById(pillId);
    if (!el) return;
    el.classList.remove("flash-green", "flash-red");
    void el.offsetWidth;
    el.classList.add(cls);
    applyTransientClass(el, "shake", 170);
  }

  // ====== RENDER ======
  function setStats() {
    document.getElementById("correctLinks").textContent = String(state.correctLinks);
    document.getElementById("mistakes").textContent = String(state.mistakes);
    const lc = lockedCount();
if (state.completedSets !== lc) state.completedSets = lc;
document.getElementById("completedSets").textContent = String(lc);

    let shown = state.elapsedMs;
    if (state.hasStarted && state.timerRunning && state.startMs) {
      shown = state.elapsedMs + (Date.now() - state.startMs);
    }
    document.getElementById("timer").textContent = fmtTime(shown);
  }

  function render() {
    setStats();
    const grid = document.getElementById("grid");
    grid.innerHTML = "";

    const qNorm = normalize(state.searchQuery);
    const displayNodes = state.nodes
      .slice()
      .sort((a,b) => a.order - b.order)
      .filter(n => nodeMatchesSearch(n, qNorm));

    for (const node of displayNodes) {
      const tile = document.createElement("div");
      tile.className = "tile " + (node.type === "stack" ? "stack" : "locked");
      tile.dataset.nodeId = node.nodeId;
      tile.setAttribute("data-node-id", node.nodeId);

      if (state.selectedNodeId === node.nodeId) tile.classList.add("selected");

      if (node.type === "stack") {
        const size = node.itemIds.length;

        const title = `Stack of ${size}`;

        // Keep the tile height fixed: if there are more than MAX_STACK_PREVIEW_ITEMS,
        // show fewer items and reserve the last visible slot for the ellipsis chip.
        const hasMore = node.itemIds.length > MAX_STACK_PREVIEW_ITEMS;
        const previewCount = hasMore ? Math.max(1, MAX_STACK_PREVIEW_ITEMS - 1) : MAX_STACK_PREVIEW_ITEMS;
        const previewIds = node.itemIds.slice(0, previewCount);

        tile.innerHTML = `
          <div class="title">${escapeHtml(title)}</div>
          <div class="meta">${escapeHtml(size === 1 ? "Single item" : "Merged stack")}</div>
          <div class="stackList">
            ${previewIds.map(id => `<div class="chip">${escapeHtml(itemById.get(id).label)}</div>`).join("")}
            ${hasMore ? `<div class="chip chip-ellipsis">(...)</div>` : ""}
          </div>
        `;

        tile.addEventListener("click", () => onTileClick(node.nodeId));
      } else {
        tile.innerHTML = `
          <div class="title">✅ ${escapeHtml(node.setName)}</div>
          <div class="meta">Completed (${TARGET_SET_SIZE} items)</div>
        `;
      }

      grid.appendChild(tile);
    }
  }

  // ====== GAME LOGIC ======
  function clearSelection() {
    state.selectedNodeId = null;
  }

  function expectedSetCount() {
  // Count unique setIds actually present in the current board's items.
  try {
    const s = new Set((items || []).map(i => i.setId));
    return s.size || 0;
  } catch {
    return 0;
  }
}

function lockedCount() {
  return (state?.nodes || []).filter(n => n.type === "locked").length;
}

function isSolved() {
  const need = expectedSetCount();
  if (!need) return false;
  return lockedCount() >= need;
}

  function onTileClick(nodeId) {
    const clicked = getNode(nodeId);
    if (!clicked || clicked.type !== "stack") return;
    const clickedId = clicked.nodeId;

    // Start timer on first interaction
    startTimerIfNeeded();

    if (!state.selectedNodeId) {
      state.selectedNodeId = nodeId;
      saveState();
      render();
      return;
    }

    if (state.selectedNodeId === nodeId) {
      clearSelection();
      saveState();
      render();
      return;
    }

    const selected = getNode(state.selectedNodeId);
    clearSelection();

    if (!selected || selected.type !== "stack") {
      saveState();
      render();
      return;
    }

    // Wrong set => mistake
    if (selected.setId !== clicked.setId) {
      state.mistakes += 1;
      saveState();
      render();
      flashNode(selected.nodeId, "flash-red");
      flashNode(clickedId, "flash-red");
      flashPill("mistakesPill", "flash-red");
      return;
    }

    // Correct merge
    const a = selected.itemIds;
    const b = clicked.itemIds;

    // New links formed when joining two groups
    state.correctLinks += 1;

    const mergedOrder = Math.min(selected.order, clicked.order);

    // Remove both old nodes
    state.nodes = state.nodes.filter(n => n.nodeId !== selected.nodeId && n.nodeId !== clicked.nodeId);

    // Completion check
    const mergedSize = a.length + b.length;

    if (mergedSize >= TARGET_SET_SIZE) {
      const setName = setById.get(selected.setId).name;
      state.nodes.push({
        nodeId: crypto.randomUUID(),
        type: "locked",
        setId: selected.setId,
        setName,
        order: mergedOrder,
      });
      state.completedSets += 1;
    } else {
      state.nodes.push({
        nodeId: crypto.randomUUID(),
        type: "stack",
        setId: selected.setId,
        itemIds: [...a, ...b],
        order: mergedOrder,
      });
    }

    if (isSolved()) {
      freezeTimer();

      // Submit to leaderboard once per completed puzzle
      if (!state.hasSubmittedWin) {
        const result = {
          mode: "stacks",
          dateKey: londonDateKey(),
          name: getPlayerName(),
          timeMs: state.elapsedMs,
          mistakes: state.mistakes,
          correctLinks: state.correctLinks,
          createdAt: Date.now(),
        };
        submitStacksRun(result);
        state.hasSubmittedWin = true;
      }

      // Win modal state (refresh-safe): show once, then don't re-show on refresh after dismissal.
      state.showWinModal = true;
      state.winModalDismissed = false;
      state.winCelebrated = false; // allow celebration once for this completion
      saveState();

      showFinishModal({ variant: "win" });
    } else {
      saveState();
    }

    render();
    flashNode(selected.nodeId, "flash-green");
    flashNode(clickedId, "flash-green");
    flashPill("correctPill", "flash-green");
  }

  // ====== RESET ======
  async function reset() {
    stopTicking();

    // Don't allow resetting a solved daily puzzle.
if (state && isSolved()) {
  showFinishModal({ variant: "already" });
  return;
}

    // Mobile fix: ensure we have today's Supabase board (or cached board) before rebuilding.
    stacksLoadPromise = null; // force re-fetch (useful after deleting today's stored row)
    try {
      await ensureStacksBoardReady();
    } catch {}

    closeFinishModal({ silent: true });

    clearSavedState();
    state = freshState();
    saveState();
    render();

    if (shouldResetHowToOnReset()) {
      localStorage.removeItem(howToKey("stacks"));
      // Re-open immediately so you can test the Start Game flow
      maybeShowHowToFor("stacks");
    }

    document.getElementById("timer").textContent = "00:00";
  }

  document.getElementById("resetBtn").addEventListener("click", reset);

// ====== STACKS FINISH MODAL ======
const finishOverlay = document.getElementById("finishOverlay");
const finishBody = document.getElementById("finishBody");
const finishCloseBtn = document.getElementById("finishCloseBtn");
const finishPlayAgainBtn = document.getElementById("finishPlayAgainBtn");
const finishHomeBtn = document.getElementById("finishHomeBtn");
const finishLeaderboardBtn = document.getElementById("finishLeaderboardBtn");
const confettiLayer = document.getElementById("confettiLayer");

// Finish modal countdown interval helpers
let finishCountdownInterval = null;

function startFinishCountdown() {
  const el = document.getElementById("finishNextBoardIn");
  if (!el) return;
  if (finishCountdownInterval) clearInterval(finishCountdownInterval);

  const tick = () => {
    el.textContent = fmtHMS(msUntilNextLondonMidnight(new Date()));
  };

  tick();
  finishCountdownInterval = setInterval(tick, 1000);
}

function stopFinishCountdown() {
  if (finishCountdownInterval) clearInterval(finishCountdownInterval);
  finishCountdownInterval = null;
}

function confettiBurstFromCorners() {
  if (!confettiLayer) return;
  confettiLayer.innerHTML = "";
  confettiLayer.classList.add("active");

  // 4 corner-ish launch bands
  const bands = [
    { min: 0, max: 18 },
    { min: 22, max: 40 },
    { min: 60, max: 78 },
    { min: 82, max: 100 },
  ];

  const count = 80;
  for (let i = 0; i < count; i++) {
    const d = document.createElement("div");
    d.className = "confetto";

    const band = bands[i % bands.length];
    const left = band.min + Math.random() * (band.max - band.min);
    const delay = Math.random() * 220;
    const hue = Math.floor(Math.random() * 360);

    d.style.left = left + "vw";
    d.style.top = (-12 - Math.random() * 22) + "px";
    d.style.background = `hsl(${hue} 90% 60%)`;
    d.style.animationDelay = delay + "ms";
    d.style.animationDuration = (950 + Math.random() * 750) + "ms";
    confettiLayer.appendChild(d);
  }

  setTimeout(() => {
    confettiLayer.classList.remove("active");
    confettiLayer.innerHTML = "";
  }, 2000);
}

function showFinishModal(opts = {}) {
  if (!finishOverlay || !finishBody) return;

  const variant = opts.variant || "win"; // "win" | "already"
  const isAlready = variant === "already";

  const titleEl = document.getElementById("finishTitle");
  if (titleEl) titleEl.textContent = isAlready ? "You’ve already completed today’s Stacks" : "Stacks complete!";

  const shown = state?.elapsedMs ?? 0;
  const nextIn = fmtHMS(msUntilNextLondonMidnight(new Date()));

  finishBody.innerHTML = `
    <p><strong>Time:</strong> ${escapeHtml(fmtTime(shown))}</p>
    <p><strong>Mistakes:</strong> ${escapeHtml(String(state?.mistakes ?? 0))} &nbsp; <strong>Correct links:</strong> ${escapeHtml(String(state?.correctLinks ?? 0))}</p>
    <p><strong>New board in:</strong> <span id="finishNextBoardIn" class="mono">${escapeHtml(nextIn)}</span></p>
    <p class="muted">Leaderboard submission happens automatically on completion.</p>
  `;

  finishOverlay.classList.add("active");
  document.body.classList.add("modal-open");

  // Celebration should only happen once per completed puzzle, and never for the "already" reminder.
  if (!isAlready && state && !state.winCelebrated) {
    confettiBurstFromCorners();
    state.winCelebrated = true;
    saveState();
  }

  startFinishCountdown();
}

function closeFinishModal(opts = {}) {
  const silent = !!opts.silent;

  if (finishOverlay) finishOverlay.classList.remove("active");
  document.body.classList.remove("modal-open");
  stopFinishCountdown();

  // Mark dismissed so refresh doesn't keep popping it.
  if (!silent && state && isSolved()) {
    state.showWinModal = false;
    state.winModalDismissed = true;
    saveState();
  }
}

finishCloseBtn?.addEventListener("click", () => closeFinishModal());
finishPlayAgainBtn?.addEventListener("click", async () => {
  closeFinishModal({ silent: true });
  await reset();
});
finishHomeBtn?.addEventListener("click", () => {
  closeFinishModal();
  showView("home");
});
finishLeaderboardBtn?.addEventListener("click", () => {
  closeFinishModal();
  showView("leaderboard");
});

  // ====== BOOT ======
  (async function boot() {
    // Ensure today's board is loaded (Supabase preferred; cache fallback; demo last).
    let supaSig = null;
    try {
      const res = await ensureStacksBoardReady();
if (res?.source) setBoardSourceLabel(res.source);
if (res && res.ok && res.signature) supaSig = res.signature;
    } catch {}

    // If the daily selection changed, wipe saved Stacks state so we don't mismatch tiles
    if (supaSig) {
      const prevSig = localStorage.getItem(STACKS_SIGNATURE_KEY);
      if (prevSig !== supaSig) {
        clearSavedState();
        localStorage.setItem(STACKS_SIGNATURE_KEY, supaSig);
      }
    }

    const loaded = loadState();
    state = loaded ?? freshState();

    // Don’t carry over selection highlight
    state.selectedNodeId = null;

    // Restore search UI
    const searchEl = document.getElementById("searchInput");
    const clearBtn = document.getElementById("clearSearchBtn");
    if (searchEl) {
      searchEl.value = state.searchQuery || "";
      searchEl.addEventListener("input", () => {
        state.searchQuery = searchEl.value;
        saveState();
        render();
      });
    }
    if (clearBtn) {
      clearBtn.addEventListener("click", () => {
        if (!searchEl) return;
        searchEl.value = "";
        state.searchQuery = "";
        saveState();
        render();
        setVersionBadges();
        searchEl.focus();
      });
    }

    render();
    resumeTimerIfRunning();

    setVersionBadges();
ensurePlayerNameWired();

const prompted = maybePromptNameFirstVisit();
if (!prompted) {
  maybeShowChangelogOncePerVersion();
}

    // If already solved and the win modal wasn't dismissed, show it once (refresh-safe)
    if (isSolved() && state && !state.winModalDismissed) {
      state.showWinModal = true;
      saveState();
      showFinishModal({ variant: "win" });
    }

    // Ensure state exists in storage
    saveState();
  })();

  // Save accumulated time on refresh/close if timer is currently running
  window.addEventListener("beforeunload", () => {
    if (state?.hasStarted && state?.timerRunning && state?.startMs) {
      state.elapsedMs += (Date.now() - state.startMs);
      state.startMs = Date.now();
      saveState();
    }
  });

  // ====== NUMERATE (Step 3 scaffolding) ======
  const NUMERATE_STATE_KEY = "numerate_state_v1";

  const numerateQuestionBank = [
    {
      id: "tube_stations",
      question: "How many London Underground stations are there?",
      answer: 272,
      unit: "stations",
      sourceName: "TfL (add link)",
      sourceUrl: "",
      asOf: "accessed 2026-01-17",
    },
    {
      id: "usd_to_gbp_1m",
      question: "To the nearest thousand pounds, how much would one million US dollars convert to?",
      answer: 747000,
      unit: "GBP",
      sourceName: "FX rate source (add link)",
      sourceUrl: "",
      asOf: "2026-01-17",
    },
    {
      id: "doctor_who_eps_since_1963",
      question: "How many episodes of Doctor Who have aired since 1963?",
      answer: 892,
      unit: "episodes",
      sourceName: "Episode count source (add link)",
      sourceUrl: "",
      asOf: "2025-05-31",
    },
    {
      id: "number_of_popes",
      question: "How many popes have there been?",
      answer: 267,
      unit: "popes",
      sourceName: "List of popes source (add link)",
      sourceUrl: "",
      asOf: "2025-05-08",
    },
    {
      id: "uk_nightclubs_closures_per_month",
      question: "On average, how many nightclubs shut per month in the UK?",
      answer: 11,
      unit: "nightclubs/month",
      sourceName: "UK closures source (add link)",
      sourceUrl: "",
      asOf: "2024-06",
    },
  ];

  let numerateState = {
  idx: 0,
  totalError: 0,
  timeLeftMs: 10000,
  inReveal: false,
  revealText: "",
  hasStarted: false,
  timerRunning: false,
  completed: false,
  usedMs: 0,
  hasSubmittedWin: false,
};

  function renderNumerate() {
    const q = numerateQuestionBank[numerateState.idx] || numerateQuestionBank[0];
    const qNum = Math.min(numerateState.idx + 1, 5);
    document.getElementById("numQ").textContent = `${qNum}/5`;
    document.getElementById("numTime").textContent = `${(numerateState.timeLeftMs / 1000).toFixed(1)}s`;
    document.getElementById("numErr").textContent = numerateState.totalError.toFixed(2);
    document.getElementById("numQuestion").textContent = q.question;
    // Show Source + As-of meta
    const metaEl = document.getElementById("numQuestionMeta");
    if (metaEl) {
      const src = q.sourceName ? `Source: ${q.sourceName}` : "Source: (add)";
      const asof = q.asOf ? `As of: ${q.asOf}` : "As of: (add)";
      metaEl.textContent = `${src} • ${asof}`;
    }
    document.getElementById("numReveal").textContent = numerateState.revealText || "";
    // UI toggles for guess input and lock/next/done button
    const guessEl = document.getElementById("numGuess");
    const lockBtn = document.getElementById("numLockBtn");
    if (guessEl) guessEl.disabled = !!numerateState.inReveal || !!numerateState.completed;
    if (lockBtn) {
      lockBtn.textContent = numerateState.completed ? "Done" : (numerateState.inReveal ? "Next" : "Lock");
      lockBtn.disabled = !!numerateState.completed;
    }
  }

  let numerateInterval = null;
let numerateLastTick = null;

function saveNumerateState() {
  try { localStorage.setItem(NUMERATE_STATE_KEY, JSON.stringify(numerateState)); } catch {}
}

function loadNumerateState() {
  try {
    const raw = localStorage.getItem(NUMERATE_STATE_KEY);
    if (!raw) return false;
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== "object") return false;

    numerateState = {
      ...numerateState,
      ...parsed,
      idx: parsed.idx ?? 0,
      totalError: parsed.totalError ?? 0,
      timeLeftMs: parsed.timeLeftMs ?? 10000,
      inReveal: parsed.inReveal ?? false,
      revealText: parsed.revealText ?? "",
      hasStarted: parsed.hasStarted ?? false,
      completed: parsed.completed ?? false,
      usedMs: parsed.usedMs ?? 0,
      hasSubmittedWin: parsed.hasSubmittedWin ?? false,
      timerRunning: false, // never auto-resume ticking after refresh
    };
    return true;
  } catch {
    return false;
  }
}

function stopNumerateTicking() {
  if (numerateInterval) clearInterval(numerateInterval);
  numerateInterval = null;
  numerateLastTick = null;
}

function startNumerateTicking() {
  stopNumerateTicking();
  numerateState.timerRunning = true;
  numerateLastTick = Date.now();

  numerateInterval = setInterval(() => {
    if (!numerateState.timerRunning || numerateState.inReveal || numerateState.completed) return;

    const now = Date.now();
    const dt = now - (numerateLastTick || now);
    numerateLastTick = now;

    numerateState.timeLeftMs = Math.max(0, numerateState.timeLeftMs - dt);

    if (numerateState.timeLeftMs <= 0) {
      lockNumerate(true);
      return;
    }

    renderNumerate();
    saveNumerateState();
  }, 100);
}

function pauseNumerate() {
  numerateState.timerRunning = false;
  stopNumerateTicking();
  saveNumerateState();
  renderNumerate();
}

function lockNumerate(auto = false) {
  if (!numerateState.hasStarted || numerateState.completed) return;
  if (numerateState.inReveal) return;

  const q = numerateQuestionBank[numerateState.idx] || numerateQuestionBank[0];
  const guessEl = document.getElementById("numGuess");
  const raw = (guessEl?.value || "").trim();

  let guess = Number(raw.replaceAll(",", ""));
  if (!Number.isFinite(guess) || guess < 0) {
    if (!auto) {
      numerateState.revealText = "Enter a valid non-negative number.";
      renderNumerate();
      return;
    }
    guess = 0; // auto-lock invalid as 0
  }

  const err = Math.abs(guess - q.answer) / q.answer;

// Track time used for this question (counts until lock moment only)
const usedThisQ = Math.min(10000, Math.max(0, 10000 - (numerateState.timeLeftMs || 0)));
numerateState.usedMs = (numerateState.usedMs || 0) + usedThisQ;

numerateState.totalError += err;

  numerateState.inReveal = true;
  numerateState.timerRunning = false;
  stopNumerateTicking();

  numerateState.revealText = `Answer: ${q.answer} ${q.unit}. You were ${(err * 100).toFixed(1)}% off. Click to continue.`;

  saveNumerateState();
  renderNumerate();
}

function resetNumerateStateOnly() {
  stopNumerateTicking();
  numerateState = {
    idx: 0,
    totalError: 0,
    timeLeftMs: 10000,
    inReveal: false,
    revealText: "",
    hasStarted: false,
    timerRunning: false,
    completed: false,
    usedMs: 0,
    hasSubmittedWin: false,
  };
  localStorage.removeItem(NUMERATE_STATE_KEY);
  const guessEl = document.getElementById("numGuess");
  if (guessEl) guessEl.value = "";
  renderNumerate();
}

function resetNumerate() {
  resetNumerateStateOnly();

  // Testing: optionally reset the How To Play loop and re-open it.
  if (shouldResetHowToOnReset()) {
    localStorage.removeItem(howToKey("numerate"));
    maybeShowHowToFor("numerate");
    return;
  }

  // Normal behavior: if the how-to has already been seen, start immediately after reset.
  if (localStorage.getItem(howToKey("numerate")) === "1") {
    startNumerateGame();
  }
}

  document.getElementById("numerateResetBtn")?.addEventListener("click", resetNumerate);
  document.getElementById("numLockBtn")?.addEventListener("click", () => {
    if (numerateState.inReveal) advanceNumerate();
    else lockNumerate(false);
  });
  document.getElementById("numGuess")?.addEventListener("keydown", (e) => {
    if (e.key !== "Enter") return;
    e.preventDefault();
    if (numerateState.inReveal) advanceNumerate();
    else lockNumerate(false);
  });
  document.getElementById("numReveal")?.addEventListener("click", () => {
    if (numerateState.inReveal) advanceNumerate();
  });

  // Render Numerate once on load so the view isn't blank.
  loadNumerateState();
  renderNumerate();

  // ====== HOW TO PLAY MODAL ======
  const howToOverlay = document.getElementById("howToOverlay");
  const howToTitle = document.getElementById("howToTitle");
  const howToBody = document.getElementById("howToBody");
  const howToStartBtn = document.getElementById("howToStartBtn");

  let pendingStartFn = null;

  function howToKey(mode) {
  if (mode === "stacks") {
    const sig = localStorage.getItem(STACKS_SIGNATURE_KEY) || londonDateKey();
    return `howto_seen_v2_stacks_${sig}`;
  }
  return `howto_seen_v1_${mode}`;
}

  function showHowTo(mode, title, htmlBody, onStart) {
    // Ensure no game timers are running behind the modal.
    if (mode === "numerate") {
      pauseNumerate();
      // Reset visible countdown to a clean 10.0s before Start Game is pressed.
      numerateState.timeLeftMs = 10000;
      numerateState.inReveal = false;
      numerateState.timerRunning = false;
      saveNumerateState();
      renderNumerate();
    }

    pendingStartFn = onStart;
    howToTitle.textContent = title;
    howToBody.innerHTML = htmlBody;
    howToOverlay.classList.add("active");
    document.body.classList.add("modal-open");
    localStorage.setItem(howToKey(mode), "1");
    // focus the start button for keyboard users
    setTimeout(() => howToStartBtn.focus(), 0);
  }

  function closeHowTo() {
  howToOverlay.classList.remove("active");
  document.body.classList.remove("modal-open");
}

howToStartBtn.addEventListener("click", async () => {
  closeHowTo();
  if (typeof pendingStartFn === "function") {
    try { await pendingStartFn(); } catch (e) { console.warn("Start failed:", e); }
  }
  pendingStartFn = null;
});

  // Clicking outside the modal does nothing (forces explicit Start)

  // ====== GAME START HOOKS (for How To Play) ======
  async function startStacksGame() {
  // Ensure today's board is ready first
  try { await ensureStacksBoardReady(); } catch {}

  // Ensure state exists (boot might still be running)
  if (!state) {
    const loaded = loadState();
    state = loaded ?? freshState();
    state.selectedNodeId = null;
    saveState();
  }

  startTimerIfNeeded();
  render();
}

  function startNumerateGame() {
    // Start NEW only if not started yet or already completed.
    if (!numerateState.hasStarted || numerateState.completed) {
      resetNumerateStateOnly();
      numerateState.hasStarted = true;
      numerateState.completed = false;
      numerateState.idx = 0;
      numerateState.totalError = 0;
      numerateState.timeLeftMs = 10000;
      numerateState.inReveal = false;
      numerateState.revealText = "";
      numerateState.usedMs = 0;
      numerateState.hasSubmittedWin = false;
    }

    // Resume ticking from current state
    numerateState.hasStarted = true;
    numerateState.timerRunning = true;
    saveNumerateState();
    renderNumerate();
    startNumerateTicking();
    document.getElementById("numGuess")?.focus();
  }

  function advanceNumerate() {
    if (!numerateState.inReveal) return;
    if (numerateState.completed) return;

    const guessEl = document.getElementById("numGuess");

    numerateState.inReveal = false;
    numerateState.revealText = "";
    if (guessEl) guessEl.value = "";

    numerateState.idx += 1;

    if (numerateState.idx >= 5) {
  numerateState.completed = true;
  numerateState.timerRunning = false;
  stopNumerateTicking();

  // Submit to local leaderboard once per completed run
  if (!numerateState.hasSubmittedWin) {
    const result = {
      mode: "numerate",
      dateKey: londonDateKey(),
      name: getPlayerName(),
      totalError: numerateState.totalError,
      timeMs: numerateState.usedMs || 0,
      createdAt: Date.now(),
    };
    submitNumerateRun(result);
    numerateState.hasSubmittedWin = true;
  }

  numerateState.revealText = `Finished! Total error: ${numerateState.totalError.toFixed(2)}.`;
  saveNumerateState();
  renderNumerate();
  return;
}

    numerateState.timeLeftMs = 10000;
    numerateState.timerRunning = true;
    saveNumerateState();
    renderNumerate();
    startNumerateTicking();
    guessEl?.focus();
  }

  function maybeShowHowToFor(mode) {
    const seen = localStorage.getItem(howToKey(mode)) === "1";
    if (seen) return false;

    if (mode === "stacks") {
      showHowTo(
        "stacks",
        "How to play: Stacks",
        `
          <p>Merge tiles into stacks by finding two items from the same hidden category.</p>
          <ul>
            <li>Click a tile to select it.</li>
            <li>Click another tile from the same category to merge them.</li>
            <li>Wrong match = a mistake.</li>
            <li>Complete a full set and it becomes a locked category block.</li>
          </ul>
          <p><strong>Tip:</strong> use the search bar to find single tiles while your multi-item stacks stay visible.</p>
        `,
        startStacksGame
      );
      return true;
    }

    if (mode === "numerate") {
      showHowTo(
        "numerate",
        "How to play: Numerate",
        `
          <p>Guess the number as closely as you can.</p>
          <ul>
            <li>You’ll get 5 questions.</li>
            <li>Each question locks after <strong>10 seconds</strong>.</li>
            <li>Your score is total percentage error (lower is better).</li>
            <li>After each lock, you’ll see the answer. (Source + as-of are shown with the question.)</li>
          </ul>
        `,
        startNumerateGame
      );
      return true;
    }

    if (mode === "timeline") {
      showHowTo(
        "timeline",
        "How to play: Timeline",
        `
          <p>Place historical events into chronological order.</p>
          <ul>
            <li>You’ll be shown 10 events (no dates revealed until the end).</li>
            <li>Place each new event into the timeline.</li>
            <li>After placing all 10, you get <strong>one final chance</strong> to reorder.</li>
            <li>Then you Lock In: score is <strong>0–10</strong> based on exact positions.</li>
          </ul>
        `,
        () => {}
      );
      return true;
    }

    return false;
  }

  let nextBoardInterval = null;

function startNextBoardCountdown() {
  const el = document.getElementById("nextBoardIn");
  if (!el) return;
  if (nextBoardInterval) clearInterval(nextBoardInterval);

  const tick = () => {
    el.textContent = fmtHMS(msUntilNextLondonMidnight(new Date()));
  };

  tick();
  nextBoardInterval = setInterval(tick, 1000);
}

function stopNextBoardCountdown() {
  if (nextBoardInterval) clearInterval(nextBoardInterval);
  nextBoardInterval = null;
}

  // ====== SIMPLE VIEW ROUTER (Step 1) ======
  let currentView = "home";
  function showView(which) {
    // Demo build: Numerate and Timeline are temporarily disabled
    if (which === "numerate" || which === "timeline") {
      which = "home";
    }
    // Leaving Numerate? Pause countdown so time doesn't run while you're away.
    if (currentView === "numerate" && which !== "numerate") {
      pauseNumerate();
    }
    document.querySelectorAll(".view").forEach(v => v.classList.remove("active"));
    const el = document.getElementById(`view-${which}`);
    if (el) el.classList.add("active");
    location.hash = which;
    if (which === "leaderboard") {
      renderLeaderboard(leaderboardMode === "all" ? "all" : "today");
      startNextBoardCountdown();
    } else {
      stopNextBoardCountdown();
    }

    if (which === "numerate") {
      renderNumerate();

      const shown = maybeShowHowToFor("numerate");

      // If how-to not shown:
      // - start a new run only if not started yet
      // - otherwise resume ticking from saved progress
      if (!shown && localStorage.getItem(howToKey("numerate")) === "1" && !howToOverlay.classList.contains("active")) {
        if (!numerateState.hasStarted) {
          startNumerateGame();
        } else if (!numerateState.completed && !numerateState.inReveal) {
          numerateState.timerRunning = true;
          saveNumerateState();
          startNumerateTicking();
        }
      }
    }
    if (which === "timeline") {
      // Show how-to on first entry; gameplay will be wired next.
      maybeShowHowToFor("timeline");
    }
    if (which === "stacks") {
      // If the puzzle is already solved, don't show How-To again.
      if (state && isSolved()) {
        // If they've dismissed the win modal, show a lighter "already completed" reminder on re-enter.
        if (state.winModalDismissed) {
          showFinishModal({ variant: "already" });
        } else if (state.showWinModal) {
          showFinishModal({ variant: "win" });
        }
      } else {
        // Only show How-To if they haven't started this board yet.
        if (state && !state.hasStarted) {
          maybeShowHowToFor("stacks");
        }
      }
    }
    currentView = which;
    setVersionBadges();
  }

  // Nav buttons
  document.getElementById("goStacks")?.addEventListener("click", () => showView("stacks"));
  document.getElementById("goNumerate")?.addEventListener("click", () => showView("numerate"));
  document.getElementById("goTimeline")?.addEventListener("click", () => showView("timeline"));
  document.getElementById("goLeaderboard")?.addEventListener("click", () => showView("leaderboard"));
  document.getElementById("homeBtn")?.addEventListener("click", () => showView("home"));
  document.getElementById("leaderboardBtn")?.addEventListener("click", () => showView("leaderboard"));
  document.getElementById("backHomeFromLB")?.addEventListener("click", () => showView("home"));
  document.getElementById("goStacksFromLB")?.addEventListener("click", () => showView("stacks"));
  document.getElementById("goNumerateFromLB")?.addEventListener("click", () => showView("numerate"));
  document.getElementById("numerateHomeBtn")?.addEventListener("click", () => showView("home"));
  document.getElementById("numerateLeaderboardBtn")?.addEventListener("click", () => showView("leaderboard"));
  document.getElementById("timelineHomeBtn")?.addEventListener("click", () => showView("home"));
  document.getElementById("timelineLeaderboardBtn")?.addEventListener("click", () => showView("leaderboard"));

  // Leaderboard view buttons
document.getElementById("lbShowToday")?.addEventListener("click", () => {
  leaderboardMode = "today";
  renderLeaderboard("today");
});
document.getElementById("lbShowAllTime")?.addEventListener("click", () => {
  leaderboardMode = "all";
  renderLeaderboard("all");
});
document.getElementById("lbClear")?.addEventListener("click", () => {
  if (hasRemoteLeaderboard()) return; // disabled in shared mode
  clearLeaderboard();
  renderLeaderboard(leaderboardMode === "all" ? "all" : "today");
});

document.getElementById("lbGameStacks")?.addEventListener("click", () => {
  leaderboardGame = "stacks";
  renderLeaderboard(leaderboardMode === "all" ? "all" : "today");
});

document.getElementById("lbGameNumerate")?.addEventListener("click", () => {
  leaderboardGame = "numerate";
  renderLeaderboard(leaderboardMode === "all" ? "all" : "today");
});

  // Name persistence
  const NAME_KEY = "puzzle_player_name_v1";
  const nameInput = document.getElementById("playerName");
  if (nameInput) {
    nameInput.value = localStorage.getItem(NAME_KEY) || "";
    nameInput.addEventListener("input", () => {
      localStorage.setItem(NAME_KEY, nameInput.value.trim());
    });
  }

  // Initialize route
  (function initRoute() {
    const hash = (location.hash || "#home").replace("#", "");
    // Demo build: only allow these routes
    if (["home", "stacks", "leaderboard"].includes(hash)) {
      showView(hash);
    } else {
      showView("home");
    }
  })();
</script>
</body>
</html>